import Splide from "https://cdn.jsdelivr.net/npm/@splidejs/splide@4.1.4/dist/js/splide.esm.min.js";

// Initialize translation strings - add this at the top of the file after the import
const translations = window.translations;
console.log(translations)
class PageNavigation {
  hamburger = document.querySelectorAll(".hamburger");
  hamburgerLines = document.querySelectorAll(".line");
  mobileMenu = document.querySelector(".mobileNavContainer");
  overlay = document.querySelector(".overlay");
  searchButton = document.querySelector("#search-btn-nav");
  navSearchBar = document.querySelector(".input-group");
  searchBar = document.getElementById("searchBar");
  cartContainer = document.querySelector(".cartContainer");
  cartBtn = document.querySelector(".cart-nav");
  cartCloseBtn = document.getElementById("closeCart");
  constructor() {
    this.initializeEventListeners();
    this.handleImagesViewPort();
    this.initializeProdSlider();
  }
  initializeEventListeners() {

// NAV MENU
    const resetHamburgerLines = () => {
      this.hamburgerLines.forEach((line) => {
        line.classList.remove("r-down", "d-none", "r-up");
      });
    };
    const updateOverlay = () => {
      if (this.mobileMenu ?. classList.contains("mobileActive") || this.navSearchBar ?. classList.contains("displaySearchBar")) {
        this.overlay ?. classList.remove("d-none");
      } else {
        this.overlay ?. classList.add("d-none");
      }
    };

// Nav
    this.hamburger.forEach((btn) => {
      btn.addEventListener("click", () => {
        this.mobileMenu ?. classList.toggle("mobileActive");
        if (this.navSearchBar ?. classList.contains("displaySearchBar")) {
          this.overlay ?. classList.remove("d-none");
          this.navSearchBar ?. classList.remove("displaySearchBar");
        } else {
          this.overlay ?. classList.toggle("d-none");
        }
        this.hamburgerLines.forEach((line, i) => {
          if (i === 0) {
            line.classList.toggle("r-down");
          } else if (i === 1) {
            line.classList.toggle("d-none");
          } else {
            line.classList.toggle("r-up");
          }
        });
      });
    });

// Search Bar
    this.searchButton ?. addEventListener("click", () => {
      this.navSearchBar ?. classList.toggle("displaySearchBar");
      if (this.mobileMenu ?. classList.contains("mobileActive")) {
        this.overlay ?. classList.remove("d-none");
      } else {
        this.overlay ?. classList.toggle("d-none");
      }
      this.mobileMenu ?. classList.remove("mobileActive");
      resetHamburgerLines();
    });
    this.searchBar.addEventListener("keydown", () => {
      updateOverlay();
      this.mobileMenu ?. classList.remove("mobileActive");
      resetHamburgerLines();
    });
    document.addEventListener("keydown", (e) => {
      if (e.code === "Backquote" || e.code === "Escape") {
        this.resetActiveComponents();
      }
    });
    this.overlay ?. addEventListener("click", this.resetActiveComponents.bind(this));

// Cart
    this.cartBtn.addEventListener("click", () => {
      this.cartContainer ?. classList.add('cartActive');
    });

    this.cartCloseBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.cartContainer ?. classList.remove('cartActive');
    })
    document.addEventListener("click", (e) => {
      if (!this.cartContainer ?. contains(e.target) && !this.cartBtn.contains(e.target)) {
        this.cartContainer ?. classList.remove('cartActive');
      }
    })
  }
  resetActiveComponents() {
    this.overlay ?. classList.add("d-none");
    this.navSearchBar ?. classList.remove("displaySearchBar");
    this.resetNavMenu();
  }
  resetNavMenu() {
    this.mobileMenu ?. classList.remove("mobileActive");
    this.hamburgerLines.forEach((line) => {
      line.classList.remove("r-down", "d-none", "r-up");
    });
  }
  handleImagesViewPort() {
    const heroImage = document.querySelector(".heroImage");
    if (! heroImage) return;
    


    const desktopHeroImageURL = heroImage.getAttribute("data-desktop-bg");
    const mobileHeroImageURL = heroImage.getAttribute("data-mobile-bg");
    const mediaQuery = window.matchMedia("(max-width:768px)");

    const updateHeroImage = () => {
      heroImage.src = mediaQuery.matches
        ? mobileHeroImageURL
        : desktopHeroImageURL;
    };

    updateHeroImage();
    mediaQuery.addEventListener("change", updateHeroImage);


  }
  initializeProdSlider() {

    const splideCheck = document.getElementsByClassName("splide").length

    if (splideCheck) {
      const mainProd = new Splide("#singleProductShowCase", {
        type: "fade",
        arrows: false,
        pagination: false,
        cover: true,
        lazyLoad: "nearby"
      });
      const prodThumbnails = new Splide("#thumbnailProductShowCase", {
        rewind: true,
        fixedWidth: 100,
        fixedHeight: 100,
        isNavigation: true,
        direction: "ttb",
        height: "auto",
        lazyLoad: "nearby",
        pagination: false,
        cover: true,
        trimSpace: true,
        breakpoints: {
          992: {
            direction: "ltr"
          },
          450: {
            fixedWidth: 60,
            fixedHeight: 40

          }
        }
      });
      mainProd.sync(prodThumbnails);
      mainProd.mount();
      prodThumbnails.mount();
    }
  }
}
const nav = new PageNavigation();

// Purchase Type

const radios = document.querySelectorAll('input[name="properties[purchase_type]"]');

// Function to update the selected styling
function updateSelection() {
  radios.forEach(radio => {

// Remove the selected style from all option containers
    radio.closest('.option-container').classList.remove('selected-option');
  });

// Find the checked radio and add the style to its container
  const selectedRadio = document.querySelector('input[name="properties[purchase_type]"]:checked');
  if (selectedRadio) {
    selectedRadio.closest('.option-container').classList.add('selected-option');
  }
}

// Listen for changes on each radio input
radios.forEach(radio => {
  radio.addEventListener('change', updateSelection);
});

// Initialize on page load
updateSelection();

// --- Cart Functionality ---
document.addEventListener('DOMContentLoaded', function() {

// Ensure proper money format is defined
  window.shopMoneyFormat = window.shopMoneyFormat || 'â‚¬{{amount}}';
  console.log('Using money format:', window.shopMoneyFormat);

// --- Setup Money Format and Shopify Helpers ---
  if (typeof Shopify === 'undefined') {
    window.Shopify = {};
  }

// Initialize or use existing Shopify.currency object
  if (!Shopify.currency) {
    Shopify.currency = {
      active: {{ cart.currency.iso_code | json }},
      rate: 1.0
    };
  }

  if (typeof Shopify.formatMoney !== 'function') {
    Shopify.formatMoney = function(cents) {
      if (! cents) return'0.00';
      


// For very small values (less than 1 cent), use higher precision
      if (cents > 0 && cents < 1) { // Convert to dollars/euros and use 4 decimal places for small values
        const smallValue = cents / 100;
        try {
          return new Intl.NumberFormat(undefined, {
            style: 'currency',
            currency: Shopify.currency.active || 'EUR',
            minimumFractionDigits: 4,
            maximumFractionDigits: 4
          }).format(smallValue);
        } catch (e) {
          console.error('Error formatting small money value:', e);
          return smallValue.toFixed(4);
        }
      }

// Normal case: standard 2 decimal place formatting
      const value = parseFloat(cents) / 100;

      try {
        return new Intl.NumberFormat(undefined, {
          style: 'currency',
          currency: Shopify.currency.active || 'EUR'
        }).format(value);
      } catch (e) {
        console.error('Error formatting money:', e);
        return value.toFixed(2);
      }
    };
  }

// --- Cart Open/Close Functions (using .cartActive) ---
  function openCart() {
    const cartContainer = document.querySelector('.cartContainer');
    if (cartContainer) {
      cartContainer.classList.add('cartActive');
    } else {
      console.error('Cart container not found.');
    }
  }
  function closeCart() {
    const cartContainer = document.querySelector('.cartContainer');
    if (cartContainer) {
      cartContainer.classList.remove('cartActive');
    }
  }

// --- Quantity Slider and Input Synchronization ---
  const quantitySlider = document.getElementById('quantitySlider');
  const quantityInput = document.getElementById('quantityInput');
  if (quantitySlider) {
    quantitySlider.min = 1;
  }
  if (quantitySlider && quantityInput) {

// Listen for slider changes.
// Ensure slider starts at same value as input
    setTimeout(() => {
      if (quantityInput && quantityInput.value) {
        quantitySlider.setAttribute('value', quantityInput.value);
      }
    }, 100);

    quantitySlider.addEventListener('change', function(e) {
      const newVal = e.detail && e.detail.value !== undefined
        ? e.detail.value
        : quantitySlider.getAttribute('value');
      quantityInput.value = newVal;
    });
    quantitySlider.addEventListener('input', function(e) {
      const newVal = e.detail && e.detail.value !== undefined
        ? e.detail.value
        : quantitySlider.getAttribute('value');
      quantityInput.value = newVal;
    });
    quantityInput.addEventListener('input', function(e) {
      const val = quantityInput.value;
      quantitySlider.setAttribute('value', val);
    });
  } else {
    console.error('Quantity slider or input not found.');
  }

// --- Discount Tiers Functionality ---
  const discountTiersElement = document.getElementById('discount-tiers-data');
  const originalPriceElement = document.getElementById('original-price-data');
  const variantPriceElement = document.getElementById('variant-price');
  const pricePerPieceElement = document.getElementById('price-per-piece');

// Initialize discount tiers functionality if elements exist
  if (originalPriceElement && quantityInput) { // Call this function immediately once the DOM loads to ensure discounts are calculated
    setTimeout(() => {
      if (quantityInput) {
        const startQuantity = parseInt(quantityInput.value) || 1;
        console.log('Triggering initial price update with quantity:', startQuantity);

// If we have a quantity slider, make sure it's also initialized
        if (quantitySlider) {
          quantitySlider.setAttribute('value', startQuantity);
        }

// Force update the price display
        updatePriceDisplay(startQuantity);
      }
    }, 50);

    let discountTiers = [];

// Check for the global discount tiers variable first
    if (window.productDiscountTiers) {
      console.log('Using global discount tiers variable:', window.productDiscountTiers);

// Manually parse if it's in string format
      if (typeof window.productDiscountTiers === 'string') {
        try {
          window.productDiscountTiers = JSON.parse(window.productDiscountTiers);
          console.log('Parsed string to JSON:', window.productDiscountTiers);
        } catch (e) {
          console.error('Error parsing string to JSON:', e);
        }
      }

// Log specific format to help diagnose
      console.log('Type after parsing:', typeof window.productDiscountTiers);
      if (typeof window.productDiscountTiers === 'object') {
        console.log('Keys:', Object.keys(window.productDiscountTiers));
      }

// Try to extract discount tiers with better error handling
      try {
        if (window.productDiscountTiers.tiers) {
          discountTiers = window.productDiscountTiers.tiers;
          console.log('Found tiers array in global variable:', discountTiers);
        } else if (Array.isArray(window.productDiscountTiers)) {
          discountTiers = window.productDiscountTiers;
          console.log('Global variable is already an array:', discountTiers);
        } else { // Try to parse it if it's a string
          if (typeof window.productDiscountTiers === 'string') {
            const parsed = JSON.parse(window.productDiscountTiers);
            if (parsed.tiers) {
              discountTiers = parsed.tiers;
              console.log('Parsed string into tiers:', discountTiers);
            } else if (Array.isArray(parsed)) {
              discountTiers = parsed;
              console.log('Parsed string into array:', discountTiers);
            }
          }
        }
      } catch (err) {
        console.error('Error parsing global discount tiers:', err);
      }

// As a fallback
      if (discountTiers.length === 0) {
        console.log('Setting fallback discount tiers');
        discountTiers = [{
            min: 5,
            discount: 1
          }];
      }
    } else { // Fallback to parsing from data attribute if global variable is not available
      try { // Parse the JSON data from the data-tiers attribute
        const tiersString = discountTiersElement.getAttribute('data-tiers');
        console.log('Raw tiers data:', tiersString);

// Debug output

// Define fallback tiers if parsing fails
        const fallbackTiers = {
          tiers: [
            {
              min: 5,
              discount: 1
            }
          ]
        };

// Try different approaches to parse the JSON
        let tiersData = fallbackTiers;

        if (tiersString && tiersString.trim() !== '') { // Method 1: Try to parse directly
          try {
            tiersData = JSON.parse(tiersString);
            console.log('Direct parsing succeeded');
          } catch (parseError) {
            console.log('Direct parsing failed, trying other methods');

// Method 2: Try to clean the string
            try {
              const cleanedString = tiersString
                .replace(/&quot;/g, '"')
                .replace(/\\/g, '')
                .replace(/^"/, '')
                .replace(/"$/, '');

              console.log('Cleaned tiers data:', cleanedString);
              tiersData = JSON.parse(cleanedString);
              console.log('Cleaned string parsing succeeded');
            } catch (cleanError) {
              console.log('Cleaned string parsing failed, trying as object');

// Method 3: Check if it's already an object
              if (typeof tiersString === 'object' && tiersString !== null) {
                console.log('Using as object directly');
                tiersData = tiersString;
              } else { // Method 4: Last resort - use a hardcoded structure
                console.log('Using fallback tiers');
                tiersData = fallbackTiers;
              }
            }
          }
        }

// Ensure the tiers property exists
        if (tiersData && tiersData.tiers) {
          discountTiers = tiersData.tiers;
        } else if (Array.isArray(tiersData)) { // Handle case where tiers might be an array directly
          discountTiers = tiersData;
        }

// Sort tiers by minimum quantity (ascending)
        if (discountTiers.length > 0) { // First sort ascending for display purposes
          discountTiers.sort((a, b) => a.min - b.min);
          console.log('Final discount tiers (sorted):', discountTiers);

// Log summary for debugging
          const tiersInfo = discountTiers.map(tier => `${
            tier.min
          }+ items: ${
            tier.discount
          }% off`).join(', ');
          console.log('Available discounts:', tiersInfo);
        }
      } catch (e) {
        console.error('Error parsing discount tiers:', e);
        console.error('Error details:', e.message);
        if (discountTiersElement) {
          console.log('Raw data attribute value:', discountTiersElement.getAttribute('data-tiers'));
        }
      }
    }

    let originalPrice = parseInt(originalPriceElement.getAttribute('data-price')) || 0;
    let piecesPerPack = parseInt(originalPriceElement.getAttribute('data-pieces')) || 1;

// Function to calculate the discounted price based on quantity
    function calculateDiscountedPrice(quantity) {
      console.log('Calculating discount for quantity:', quantity);

// Check if we're on the first variant - only apply discounts to first variant
      const selectedVariant = document.querySelector('#package-options .package-box.selected');
      const allVariants = document.querySelectorAll('#package-options .package-box');
      const isFirstVariant = selectedVariant && allVariants.length > 0 && selectedVariant === allVariants[0];

      if (! isFirstVariant) {
        console.log('Not the first variant, no discount applied');
        return originalPrice;
      }

      if (!window.discountTiers || !window.discountTiers.tiers || !window.discountTiers.tiers.length) {
        console.log('No discount tiers available, returning original price:', originalPrice);
        return originalPrice;
      }

      console.log('Available discount tiers:', window.discountTiers.tiers);

// Find applicable discount tier
      let applicableTier = null;

// First ensure tiers are sorted by minimum quantity in descending order
// to get the highest applicable tier first
      const sortedTiers = [...window.discountTiers.tiers].sort((a, b) => b.min - a.min);

      console.log('Sorted tiers (descending):', sortedTiers);

// Find the highest tier where quantity meets or exceeds minimum
      for (const tier of sortedTiers) {
        if (quantity >= tier.min) {
          applicableTier = tier;
          break; // Stop at first match (highest tier)
        }
      }

      console.log('Found applicable tier:', applicableTier);

      if (applicableTier) { // Calculate discount as a percentage (discount value is the percentage off)
        const discountPercentage = applicableTier.discount; // This is already the percentage value
        const discountAmount = Math.floor((originalPrice * discountPercentage) / 100);
        const discountedPrice = Math.max(0, originalPrice - discountAmount);

        console.log('Calculated discount:', {
          originalPrice,
          discountPercentage: discountPercentage + '%',
          discountAmount,
          discountedPrice,
          tier: applicableTier
        });

        return discountedPrice; // Apply percentage-based discount to original price
      }console.log('No applicable tier found, returning original price:', originalPrice);
      return originalPrice;
    }

// Function to update price display based on quantity
    function updatePriceDisplay(quantity) {
      quantity = parseInt(quantity) || 1;

      console.log('Updating price display with quantity:', quantity);
      console.log('Current price data:', {originalPrice, piecesPerPack, discountTiers: discountTiers.length});

// Check if we're on the first variant - only apply discounts to first variant
      const selectedVariant = document.querySelector('#package-options .package-box.selected');
      const allVariants = document.querySelectorAll('#package-options .package-box');
      const isFirstVariant = selectedVariant && allVariants.length > 0 && selectedVariant === allVariants[0];

// Check if we have valid discount tiers before applying any logic
      const hasValidTiers = isFirstVariant && discountTiers && discountTiers.length > 0;

// Calculate the discounted price per item
      const discountedPricePerItem = hasValidTiers
        ? calculateDiscountedPrice(quantity)
        : originalPrice;
      const totalPrice = discountedPricePerItem * quantity;

      console.log('Calculated prices:', {discountedPricePerItem, totalPrice, hasValidTiers});

// Find applicable discount tier (only if we have valid tiers)
      let applicableTier = null;
      if (hasValidTiers && window.discountTiers && window.discountTiers.tiers) { // Sort tiers by min value in descending order
        const sortedTiers = [...window.discountTiers.tiers].sort((a, b) => b.min - a.min);

// Find first tier where quantity is greater than or equal to min
        for (const tier of sortedTiers) {
          if (quantity >= tier.min) {
            applicableTier = tier;
            break;
          }
        }
      }

      console.log('Applicable tier:', applicableTier);

// Update the price display
      if (variantPriceElement) { // Store the raw amounts in data attributes
        variantPriceElement.setAttribute('data-price', totalPrice);
        const pricePerPiece = discountedPricePerItem / piecesPerPack;
        variantPriceElement.setAttribute('data-price-per-piece', pricePerPiece);

// Use the template's money filter for display
        variantPriceElement.innerHTML = `
          <span class="js-price">{{ totalPrice | money }}</span>
          <span class="perPiece pb-2" id="price-per-piece">
            (<span class="js-price-per-piece">{{ pricePerPiece | money }}</span>) per ${
          window.unitLabel || 'piece'
        }
          </span>`;

// Replace the placeholders with actual formatted values using Shopify's money filter
        const priceElements = variantPriceElement.querySelectorAll('.js-price');
        priceElements.forEach(el => {
          el.textContent = Shopify.formatMoney(totalPrice);
        });

        const pricePerPieceElements = variantPriceElement.querySelectorAll('.js-price-per-piece');
        pricePerPieceElements.forEach(el => {

// Use the raw pricePerPiece value without any additional parsing that could lose precision
          el.textContent = Shopify.formatMoney(pricePerPiece);
        });

// Handle compare price display
        const comparePrice = document.getElementById('compare-price');
        if (comparePrice) { // Check if there's a valid compare-at-price to show
          const selectedVariant = document.querySelector('#package-options .package-box.selected');
          const variantCompareAtPrice = selectedVariant
            ? parseInt(selectedVariant.getAttribute('data-compare-at-price')) || 0
            : 0;

          if (variantCompareAtPrice && variantCompareAtPrice > originalPrice) { // Get the current quantity and multiply the compare-at-price by it
            const currentQuantity = parseInt(quantityInput.value) || 1;
            const totalCompareAtPrice = variantCompareAtPrice * currentQuantity;

// Store raw value
            comparePrice.setAttribute('data-compare-price', totalCompareAtPrice);

// Format for display
            comparePrice.textContent = Shopify.formatMoney(totalCompareAtPrice);
            comparePrice.classList.remove('d-none');

// Still hide it if discount badge is visible and we're on the first variant with a discount tier
            const discountBadge = document.querySelector('.discount-percentage-badge');
            if (isFirstVariant && applicableTier && discountBadge && discountBadge.style.display === 'block') {
              comparePrice.style.display = 'none';
            } else {
              comparePrice.style.display = 'block';
            }
          } else { // No compare-at-price for this variant, hide it
            comparePrice.classList.add('d-none');
            comparePrice.style.display = 'none';
          }
        }

// Handle discount display
        const discountContainer = document.querySelector('.discount-container');
        if (discountContainer) { // Remove any existing discount spans
          const existingDiscounts = discountContainer.querySelectorAll('.discount-price-product');
          existingDiscounts.forEach(discount => discount.remove());

// Only add discount span if we're on the first variant and there's an applicable discount
          if (isFirstVariant && applicableTier) {
            const originalTotalPrice = originalPrice * quantity;
            const formattedOriginalPrice = Shopify.formatMoney(originalTotalPrice, window.shopMoneyFormat);

            const discountSpan = document.createElement('span');
            discountSpan.className = 'discount-price-product roboto-font user-select-none';
            discountSpan.textContent = formattedOriginalPrice;
            discountContainer.appendChild(discountSpan);

// When discount tier is applied, hide the compare price
            if (comparePrice) {
              comparePrice.style.display = 'none';
            }
          } else { // When no discount tier is applied, show the compare price
            if (comparePrice) {
              comparePrice.style.display = 'block';
            }
          }
        }

// Update discount badge display
        const discountBadge = document.querySelector('.discount-percentage-badge');
        if (discountBadge) {
          if (isFirstVariant && applicableTier) {
            discountBadge.textContent = `-${
              applicableTier.discount
            }%`;
            discountBadge.style.display = 'block';

// Hide compare price when discount badge is visible
            const comparePrice = document.getElementById('compare-price');
            if (comparePrice) {
              comparePrice.style.display = 'none';
            }
          } else {
            discountBadge.style.display = 'none';

// When discount badge is not visible, show compare price
            if (comparePrice) {
              comparePrice.style.display = 'block';
            }
          }
        }
      }

// Update discount text display
      const discountDisplay = document.getElementById('discountDisplay');
      if (discountDisplay) {
        if (isFirstVariant && applicableTier) {
          const originalTotalPrice = originalPrice * quantity;
          const discountAmount = originalTotalPrice - totalPrice;
          const formattedDiscountAmount = Shopify.formatMoney(discountAmount, window.shopMoneyFormat);

// Update discount display text with raw value in data attribute
          discountDisplay.setAttribute('data-discount-amount', discountAmount);
          const discountText = `${
            translations.youCurrentlySave
          } ${
            Shopify.formatMoney(discountAmount)
          } ${
            translations.offYourTotalOrder
          }`;
          discountDisplay.textContent = discountText;
          discountDisplay.classList.add('text-discount');
        } else {
          discountDisplay.textContent = '';
          discountDisplay.classList.remove('text-discount');
        }
      }
    }

// Update price on quantity change
    quantityInput.addEventListener('input', function() {
      updatePriceDisplay(this.value);

// Also update compare-at-price when quantity changes
      const comparePrice = document.getElementById('compare-price');
      if (comparePrice && comparePrice.style.display !== 'none') {
        const selectedVariant = document.querySelector('#package-options .package-box.selected');
        const variantCompareAtPrice = selectedVariant
          ? parseInt(selectedVariant.getAttribute('data-compare-at-price')) || 0
          : 0;

        if (variantCompareAtPrice && variantCompareAtPrice > originalPrice) {
          const quantity = parseInt(this.value) || 1;
          const totalCompareAtPrice = variantCompareAtPrice * quantity;
          comparePrice.textContent = Shopify.formatMoney(totalCompareAtPrice, window.shopMoneyFormat);
        }
      }
    });

// Listen for slider changes and update price
    if (quantitySlider) { // Update prices when slider changes
      quantitySlider.addEventListener('change', function(e) {
        const newVal = e.detail && e.detail.value !== undefined
          ? e.detail.value
          : quantitySlider.getAttribute('value');
        updatePriceDisplay(newVal);

// Also update compare-at-price when slider changes
        const comparePrice = document.getElementById('compare-price');
        if (comparePrice && comparePrice.style.display !== 'none') {
          const selectedVariant = document.querySelector('#package-options .package-box.selected');
          const variantCompareAtPrice = selectedVariant
            ? parseInt(selectedVariant.getAttribute('data-compare-at-price')) || 0
            : 0;

          if (variantCompareAtPrice && variantCompareAtPrice > originalPrice) {
            const quantity = parseInt(newVal) || 1;
            const totalCompareAtPrice = variantCompareAtPrice * quantity;
            comparePrice.textContent = Shopify.formatMoney(totalCompareAtPrice, window.shopMoneyFormat);
          }
        }
      });

      quantitySlider.addEventListener('input', function(e) {
        const newVal = e.detail && e.detail.value !== undefined
          ? e.detail.value
          : quantitySlider.getAttribute('value');
        updatePriceDisplay(newVal);

// Also update compare-at-price when slider changes
        const comparePrice = document.getElementById('compare-price');
        if (comparePrice && comparePrice.style.display !== 'none') {
          const selectedVariant = document.querySelector('#package-options .package-box.selected');
          const variantCompareAtPrice = selectedVariant
            ? parseInt(selectedVariant.getAttribute('data-compare-at-price')) || 0
            : 0;

          if (variantCompareAtPrice && variantCompareAtPrice > originalPrice) {
            const quantity = parseInt(newVal) || 1;
            const totalCompareAtPrice = variantCompareAtPrice * quantity;
            comparePrice.textContent = Shopify.formatMoney(totalCompareAtPrice, window.shopMoneyFormat);
          }
        }
      });
    }

// Initialize price display with default quantity
    updatePriceDisplay(quantityInput.value || 1);

// Set up debug button
    const debugTiersBtn = document.getElementById('debug-tiers-btn');
    if (debugTiersBtn) {
      debugTiersBtn.addEventListener('click', function() {
        console.log('------ DISCOUNT TIERS DEBUG ------');
        console.log('Current discount tiers:', discountTiers);
        console.log('Original price:', originalPrice);
        console.log('Pieces per pack:', piecesPerPack);

// Sort tiers correctly for display
        const sortedTiers = [... discountTiers].sort((a, b) => a.min - b.min);
        let debugInfo = "Discount Tiers:\n";

        sortedTiers.forEach(tier => {
          debugInfo += `â€¢ ${
            tier.min
          }+ items: ${
            tier.discount
          }% off\n`;
        });

// Test with several quantities
        debugInfo += "\nSample quantities:\n";
        const testQuantities = [
          1,
          3,
          5,
          7,
          10,
          15,
          20,
          30,
          40,
          50
        ];

        testQuantities.forEach(qty => {
          const discountedPrice = calculateDiscountedPrice(qty);
          const tier = discountTiers.find(t => qty >= t.min);

          debugInfo += `â€¢ Qty ${qty}: `;
          if (tier) {
            const discountAmount = (originalPrice * tier.discount) / 100;
            const totalDiscount = discountAmount * qty;

            debugInfo += `${
              Shopify.formatMoney(discountedPrice * qty, window.shopMoneyFormat)
            } `;
            debugInfo += `(${
              tier.discount
            }% off, saves ${
              Shopify.formatMoney(totalDiscount, window.shopMoneyFormat)
            })\n`;
          } else {
            debugInfo += `${
              Shopify.formatMoney(originalPrice * qty, window.shopMoneyFormat)
            } (no discount)\n`;
          }
        });

        alert(debugInfo);

// Force a specific discount for testing
        if (discountTiers.length > 0) { // Find the highest tier for a good test
          const highestTier = [... discountTiers].sort((a, b) => b.min - a.min)[0];
          const testQuantity = highestTier.min;

// Update UI elements
          quantityInput.value = testQuantity;

          if (quantitySlider) {
            quantitySlider.setAttribute('value', testQuantity);
          }

// Force recalculate price with discount
          updatePriceDisplay(testQuantity);

          console.log(`Testing with quantity ${testQuantity} to see highest discount tier`);
        } else {
          alert('No discount tiers defined. Please set up discount tiers in the metafield.');
        }
      });
    }

// Handle variant selection
    const packageBoxes = document.querySelectorAll('#package-options .package-box');
    if (packageBoxes.length > 0) {
      console.log('Found package boxes:', packageBoxes.length);

// Add initial styling to package boxes to make them more interactive
      packageBoxes.forEach(box => {
        box.style.cursor = box.classList.contains('out-of-stock')
          ? 'not-allowed'
          : 'pointer';
        box.addEventListener('mouseover', () => {
          if (!box.classList.contains('selected') && !box.classList.contains('out-of-stock')) {
            box.style.backgroundColor = 'rgba(26, 54, 131, 0.02)';
          }
        });
        box.addEventListener('mouseout', () => {
          if (!box.classList.contains('selected') && !box.classList.contains('out-of-stock')) {
            box.style.backgroundColor = '';
          }
        });
      });

      packageBoxes.forEach(box => {
        box.addEventListener('click', function() {

// Don't allow selection of out of stock variants
          if (this.classList.contains('out-of-stock')) {
            return;
          }

          console.log('Package box clicked');

// Remove selected class from all boxes
          packageBoxes.forEach(b => b.classList.remove('selected'));

// Add selected class to clicked box
          this.classList.add('selected');

// Update form's variant ID
          const variantId = this.getAttribute('data-variant-id');
          const form = document.querySelector('.add-to-cart-form');
          if (form) {
            form.setAttribute('data-variant-id', variantId);

// Update add to cart button state
            const addToCartBtn = form.querySelector('button[type="submit"]');
            const isAvailable = this.getAttribute('data-available') === 'true';
            if (addToCartBtn) {
              addToCartBtn.disabled = ! isAvailable;
              addToCartBtn.textContent = isAvailable
                ? translations.addToCart
                : translations.outOfStock;
              addToCartBtn.setAttribute(
                'aria-label',
                isAvailable
                  ? translations.addToCart
                  : translations.outOfStock
              );
            }
          }

// Set quantity to 1
          if (quantityInput) {
            quantityInput.value = 1;
          }

// Set quantity slider to 1
          if (quantitySlider) {
            quantitySlider.setAttribute('value', 1);
          }

// Update internal variables
          const variantPrice = parseInt(this.getAttribute('data-price')) || originalPrice;
          const variantPieces = parseInt(this.getAttribute('data-pieces')) || piecesPerPack;
          const variantCompareAtPrice = parseInt(this.getAttribute('data-compare-at-price')) || 0;

// Update data attributes and internal variables
          if (originalPriceElement) {
            originalPriceElement.setAttribute('data-price', variantPrice);
            originalPriceElement.setAttribute('data-pieces', variantPieces);

// Update the internal originalPrice variable used for calculations
            originalPrice = variantPrice;
            piecesPerPack = variantPieces;
          }

// Update compare price when variant changes
          const comparePrice = document.getElementById('compare-price');
          if (comparePrice) { // Only show compare price if variant has a compare-at-price and it's higher than the regular price
            if (variantCompareAtPrice && variantCompareAtPrice > variantPrice) { // Get the current quantity and multiply the compare-at-price by it
              const currentQuantity = parseInt(quantityInput.value) || 1;
              const totalCompareAtPrice = variantCompareAtPrice * currentQuantity;
              comparePrice.textContent = Shopify.formatMoney(totalCompareAtPrice, window.shopMoneyFormat);
              comparePrice.classList.remove('d-none');

// Check if this is the first variant - only then might we need to hide the compare price for discounts
              const isFirstVariant = this === packageBoxes[0];

// Still hide it if discount badge is visible and we're on the first variant
              const discountBadge = document.querySelector('.discount-percentage-badge');
              if (isFirstVariant && discountBadge && discountBadge.style.display === 'block') {
                comparePrice.style.display = 'none';
              } else {
                comparePrice.style.display = 'block';
              }
            } else { // No compare-at-price for this variant, hide it
              comparePrice.classList.add('d-none');
              comparePrice.style.display = 'none';
            }
          }

// Clean up any existing discount elements
          const discountContainer = document.querySelector('.discount-container');
          if (discountContainer) { // Remove all existing discount spans
            const existingDiscounts = discountContainer.querySelectorAll('.discount-price-product');
            existingDiscounts.forEach(discount => discount.remove());
          }

// Hide discount badge if not first variant
          const discountBadge = document.querySelector('.discount-percentage-badge');
          if (discountBadge && this !== packageBoxes[0]) {
            discountBadge.style.display = 'none';
          }

// Hide discount text if not first variant
          const discountDisplay = document.getElementById('discountDisplay');
          if (discountDisplay && this !== packageBoxes[0]) {
            discountDisplay.textContent = '';
            discountDisplay.classList.remove('text-discount');
          }

// Use quantity = 1
          const currentQuantity = 1;

// Trigger the discount display update, which will handle price updates
          if (discountDisplay) { // If we have our new discount display component
            const event = new Event('input');
            quantityInput.dispatchEvent(event);
          } else { // Fallback to the older system
            updatePriceDisplay(currentQuantity);
          }
        });
      });

// Select first variant by default if none is selected
      if (!document.querySelector('#package-options .package-box.selected')) {
        console.log('No variant selected, selecting first one by default');
        const firstBox = packageBoxes[0];
        if (firstBox) {
          firstBox.classList.add('selected');

// Get the variant data
          const variantId = firstBox.getAttribute('data-variant-id');
          let variantPrice = parseInt(firstBox.getAttribute('data-price')) || originalPrice;
          let variantPieces = parseInt(firstBox.getAttribute('data-pieces')) || piecesPerPack;

          console.log('Initial variant selection:', {variantId, variantPrice, variantPieces});

// Update the form
          const form = document.querySelector('.add-to-cart-form');
          if (form) {
            form.setAttribute('data-variant-id', variantId);
          }

// Set quantity to 1
          if (quantityInput) {
            quantityInput.value = 1;
          }

// Set quantity slider to 1
          if (quantitySlider) {
            quantitySlider.setAttribute('value', 1);
          }

// Update internal variables
          originalPrice = variantPrice;
          piecesPerPack = variantPieces;

// Update data attributes
          if (originalPriceElement) {
            originalPriceElement.setAttribute('data-price', variantPrice);
            originalPriceElement.setAttribute('data-pieces', variantPieces);
          }

// Update subscription price
          const subscriptionPriceElement = document.querySelector('.subscription-Price');
          const subscriptionPriceSpan = document.getElementById('subscription-price');

          if (subscriptionPriceElement && subscriptionPriceSpan) {
            const subscriptionPrice = variantPrice * 0.7; // 30% discount
            subscriptionPriceElement.innerHTML = Shopify.formatMoney(subscriptionPrice, window.shopMoneyFormat) + ' <span class="discount-price-product roboto-font user-select-none" id="subscription-price">' + Shopify.formatMoney(variantPrice, window.shopMoneyFormat) + '</span>';
          }

// Use quantity = 1
          const currentQuantity = 1;

// Trigger the discount display update, which will handle price updates
          const discountDisplay = document.getElementById('discountDisplay');
          if (discountDisplay) { // If we have our new discount display component
            const event = new Event('input');
            quantityInput.dispatchEvent(event);
          } else { // Fallback to the older system
            updatePriceDisplay(currentQuantity);
          }
        }
      }
    }
  }

// --- Add to Cart Event Listener ---
  const addToCartForms = document.querySelectorAll('.add-to-cart-form');
  if (addToCartForms.length === 0 && quantityInput) {
    console.error('No add-to-cart forms found.');
  }
  addToCartForms.forEach(function(form) {
    form.addEventListener('submit', function(e) {
      e.preventDefault();
      const variantId = form.getAttribute('data-variant-id');
      if (! variantId) {
        console.error('Variant ID not found on form.');
        return;
      }

// Get the quantity from the input field
      const quantity = parseInt(quantityInput ?. value, 10) || 1;
      console.log('Submitting Add to Cart for variant:', variantId, 'Quantity:', quantity);

// Check if this is the first variant
      const selectedVariant = document.querySelector('#package-options .package-box.selected');
      const allVariants = document.querySelectorAll('#package-options .package-box');
      const isFirstVariant = selectedVariant && allVariants.length > 0 && selectedVariant === allVariants[0];

// Pass discount tiers to the cart as a property if they exist AND this is the first variant
      let properties = {};
      if (isFirstVariant && window.discountTiers && window.discountTiers.tiers && window.discountTiers.tiers.length > 0) {
        properties._discount_tiers = JSON.stringify(window.discountTiers.tiers);
        console.log('Adding discount tiers to cart:', properties._discount_tiers);
      }

      addToCart(variantId, quantity, properties);
    });
  });

  function addToCart(variantId, quantity, properties = {}) {

// Store discount tiers in local storage to ensure they're properly handled
    if (properties._discount_tiers) {
      try {
        localStorage.setItem('last_added_discount_tiers', properties._discount_tiers);
      } catch (e) {
        console.error('Error storing discount tiers in local storage:', e);
      }
    }

    fetch('/cart/add.js', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(
        {id: variantId, quantity: quantity, properties: properties}
      )
    }).then(response => response.json()).then(data => {
      console.log('Item added:', data);
      updateCartUI();
      openCart();
    }).catch(error => console.error('Error adding item:', error));
  }

// --- Update Cart UI ---
  function updateCartUI() {
    fetch('/cart.js').then(response => response.json()).then(cart => {
      console.log('Cart data:', cart);

// Update cart count
      const cartCountElem = document.querySelector('.cart-count');
      if (cartCountElem) {
        cartCountElem.textContent = cart.item_count;
      } else {
        console.error('Cart count element not found.');
      }

// Variables to track totals
      let rawSubtotal = 0;
      let discountedSubtotal = 0;

// Build cart items HTML
      let itemsHtml = '';
      if (cart.items.length === 0) {
        itemsHtml = `<div class="cartItemsContainer bg-white rounded-8">
                       <h3 class="text-center pt-3">${
          translations.yourCartIsEmpty
        }</h3>
                     </div>`;
      } else { // First calculate raw and discounted subtotals
        cart.items.forEach(function(item) {
          console.log('Processing cart item:', item.title, 'with properties:', item.properties);

// Get product-specific discount tiers from item properties
          let discountTiers = [];
          let hasDiscountProperty = false;
          if (item.properties && item.properties._discount_tiers) {
            try {
              discountTiers = JSON.parse(item.properties._discount_tiers);
              hasDiscountProperty = true;
              console.log('Found discount tiers in item properties:', discountTiers);
            } catch (e) {
              console.error('Error parsing discount tiers from item properties:', e);
            }
          }

// Original price (before any discounts)
          let itemOriginalPrice = item.original_price || item.price;

// Current price (may already include discounts from Shopify)
          let itemPrice = item.final_price || item.price;

          console.log('Item price details:', {
            title: item.title,
            originalPrice: itemOriginalPrice,
            currentPrice: itemPrice,
            hasDiscountProperty,
            quantity: item.quantity
          });

// Apply discount tiers if available and not already applied
// Only items with _discount_tiers property (first variant) are eligible for quantity discounts
          if (hasDiscountProperty && discountTiers && discountTiers.length > 0) { // Sort tiers by min value in descending order
            const sortedTiers = [... discountTiers].sort((a, b) => b.min - a.min);

// Find applicable tier based on item quantity
            let applicableTier = null;
            for (const tier of sortedTiers) {
              if (item.quantity >= tier.min) {
                applicableTier = tier;
                break;
              }
            }

// If we found an applicable tier, calculate the discounted price
            if (applicableTier) {
              const discountPercentage = applicableTier.discount;

// Calculate the discount amount EXACTLY as done on the product page
              const discountAmount = Math.floor((itemOriginalPrice * discountPercentage) / 100);
              const tieredDiscountPrice = Math.max(0, itemOriginalPrice - discountAmount);

// Always use our calculated discount
              itemPrice = tieredDiscountPrice;

              console.log('Applied cart discount:', {itemOriginalPrice, discountPercentage, discountAmount, tieredDiscountPrice});
            }
          }

// Add to running totals
          rawSubtotal += (itemOriginalPrice * item.quantity);
          discountedSubtotal += (itemPrice * item.quantity);

// Store raw values for display
          const itemTotal = itemPrice * item.quantity;
          const itemOriginalTotal = itemOriginalPrice * item.quantity;

// Show discount in the cart item if we have the discount property and the price is different
          const showDiscount = hasDiscountProperty && itemPrice < itemOriginalPrice;

          itemsHtml += `
            <div class="cartItemContainer d-flex align-items-center px-md-4 px-2 py-3" data-key="${
            item.key
          }" data-price="${itemTotal}" data-original-price="${itemOriginalTotal}">
              <div class="prodImage rounded-8">
                <img loading="lazy" src="${
            item.image
          }" alt="${
            item.title
          }" height="100" width="100" />
              </div>
              <div class="prod-info flex-grow-1 ps-3">
                <p class="title text-uppercase">${
            item.product_title
          }</p>
                <div class="d-flex align-items-center py-md-3 py-1">
                  <span class="original-price funnel-font ${
            showDiscount
              ? ''
              : 'd-none'
            }">
                    ${
            showDiscount
              ? Shopify.formatMoney(itemOriginalTotal)
              : ''
            }
                  </span>
                  <h3 class="current-price fw-bold ps-2">
                    ${
            Shopify.formatMoney(itemTotal)
          }
                  </h3>
                </div>
                <div class="d-flex align-items-center justify-content-between">
                  <div class="quantity rounded-8 d-flex align-items-center justify-content-around">
                    <button class="btn-white p-2 btn-minus" data-key="${
            item.key
          }">
                      <img id="quantityBtnM" src="{{'minus.svg' | asset_url}}" width="20" height="20" alt="minus">
                    </button>
                    <div class="quantity-container">
                      <p class="quantity-number">${
            item.quantity
          }</p>
                      <div class="loader"></div>
                    </div>
                    <button class="btn-white p-2 btn-plus" data-key="${
            item.key
          }">
                      <img id="quantityBtnP" src="{{'plus.svg' | asset_url}}" width="10" height="10" alt="plus">
                    </button>
                  </div>
                  <p type="button" class="underline fw-bold funnel-font remove-item" data-key="${
            item.key
          }">Remove Item TEst</p>
                </div>
              </div>
            </div>
          `;
        });
      }

      const cartItemsContainer = document.querySelector('.cartItemsContainer');
      if (cartItemsContainer) {
        cartItemsContainer.innerHTML = itemsHtml;
      } else {
        console.error('Cart items container not found.');
      }

// Update order discounts text
      const orderDiscountElem = document.getElementById('order-discounts');
      if (orderDiscountElem) {
        const discountAmount = rawSubtotal - discountedSubtotal;
        if (discountAmount > 0) {
          orderDiscountElem.setAttribute('data-discount', discountAmount);
          orderDiscountElem.textContent = '-' + Shopify.formatMoney(discountAmount);
        } else {
          orderDiscountElem.setAttribute('data-discount', 0);
          orderDiscountElem.textContent = '-' + Shopify.formatMoney(0);
        }
      }

// Calculate and display estimated shipping costs
      const shippingCostsElement = document.getElementById('shipping-costs');
      if (shippingCostsElement) { // If cart is empty, show nothing for shipping cost
        if (cart.items.length === 0) {
          shippingCostsElement.textContent = '';
          shippingCostsElement.removeAttribute('data-shipping-cost');
          shippingCostsElement.classList.remove('free');

// Skip the rest of shipping calculation
        } else { // Use our fixed threshold from settings (always in shop's default currency)
          const freeShippingThreshold = window.freeShippingThreshold || {{ settings.free_shipping_threshold | default: 10000 }};

// Convert the cart total back to the shop's default currency for comparison
// This ensures that Albanian LEK or any other currency works consistently
          const currentCurrencyRate = Shopify.currency
            ? (Shopify.currency.rate || 1.0)
            : 1.0;
          const cartTotalInDefaultCurrency = Math.round(discountedSubtotal / currentCurrencyRate);

          console.log('Free shipping check:', {
            cartTotal: discountedSubtotal,
            cartTotalInDefaultCurrency,
            freeShippingThreshold,
            currentCurrency: Shopify.currency
              ? Shopify.currency.active
              : 'unknown',
            currencyRate: currentCurrencyRate
          });

          if (cartTotalInDefaultCurrency >= freeShippingThreshold) {
            const freeShippingLabel = window.translations.freeShippingLabel || window.translations.free;
            shippingCostsElement.textContent = freeShippingLabel;
            shippingCostsElement.setAttribute('data-shipping-cost', 0);
            shippingCostsElement.classList.add('free');
          } else {
            shippingCostsElement.classList.remove('free');
            fetch('/cart/shipping_rates.json?shipping_address[country]=                                          {{ shop.address.country | json }} &shipping_address[province]={{ shop.address.province | json }}').then(response => {
              if (!response.ok) { // If shipping rates can't be fetched, use a default estimate
                const defaultShippingCost = {{ section.settings.default_shipping_cost | default: 300 }};

// Convert shipping cost to current currency
                const currentCurrencyRate = Shopify.currency
                  ? (Shopify.currency.rate || 1.0)
                  : 1.0;
                const convertedShippingCost = Math.round(defaultShippingCost * currentCurrencyRate);

                shippingCostsElement.setAttribute('data-shipping-cost', convertedShippingCost);
                shippingCostsElement.textContent = Shopify.formatMoney(convertedShippingCost);
                throw new Error('Failed to fetch shipping rates');
              }
              return response.json();
            }).then(data => {
              if (data.shipping_rates && data.shipping_rates.length > 0) { // Sort by price and select the lowest
                const lowestRate = data.shipping_rates.sort((a, b) => a.price - b.price)[0];
                const shippingCost = lowestRate.price * 100;
                shippingCostsElement.setAttribute('data-shipping-cost', shippingCost);
                shippingCostsElement.textContent = Shopify.formatMoney(shippingCost);
              } else { // No shipping rates available, use default
                const defaultShippingCost = {{ section.settings.default_shipping_cost | default: 300 }};

// Convert shipping cost to current currency
                const currentCurrencyRate = Shopify.currency
                  ? (Shopify.currency.rate || 1.0)
                  : 1.0;
                const convertedShippingCost = Math.round(defaultShippingCost * currentCurrencyRate);

                shippingCostsElement.setAttribute('data-shipping-cost', convertedShippingCost);
                shippingCostsElement.textContent = Shopify.formatMoney(convertedShippingCost);
              }
            }).catch(error => {
              console.error('Error fetching shipping rates:', error);

// Use default shipping cost on error
              const defaultShippingCost = {{ section.settings.default_shipping_cost | default: 300 }};

// Convert shipping cost to current currency
              const currentCurrencyRate = Shopify.currency
                ? (Shopify.currency.rate || 1.0)
                : 1.0;
              const convertedShippingCost = Math.round(defaultShippingCost * currentCurrencyRate);

              shippingCostsElement.setAttribute('data-shipping-cost', convertedShippingCost);
              shippingCostsElement.textContent = Shopify.formatMoney(convertedShippingCost);
            });
          }
        }
      }

// Update all subtotal elements
      document.querySelectorAll('.cart-subtotal').forEach(function(subtotalElem) {
        subtotalElem.setAttribute('data-subtotal', discountedSubtotal);
        subtotalElem.textContent = Shopify.formatMoney(discountedSubtotal);
      });
    }).catch(error => console.error('Error updating cart UI:', error));
  }

// --- Event Delegation for Quantity Buttons & Remove Links ---
  document.addEventListener('click', function(e) {

// Plus button
    const plusButton = e.target.closest('.btn-plus');
    if (plusButton) {
      const key = plusButton.getAttribute('data-key');
      if (key) {
        updateCartItemQuantity(key, 1);
        return;
      }
    }

// Minus button
    const minusButton = e.target.closest('.btn-minus');
    if (minusButton) {
      const key = minusButton.getAttribute('data-key');
      if (key) {
        updateCartItemQuantity(key, -1);
        return;
      }
    }

// Remove button
    const removeButton = e.target.closest('.remove-item');
    if (removeButton) {
      e.preventDefault();
      const key = removeButton.getAttribute('data-key');
      if (key) {
        updateCartItemQuantity(key, 0);
        return;
      }
    }
  });
  function updateCartItemQuantity(itemKey, change) {
    console.log('Updating quantity for key:', itemKey, 'Change:', change);

// Show loader and hide quantity number for the specific cart item
    const cartItem = document.querySelector(`.cartItemContainer[data-key="${itemKey}"]`);
    if (cartItem) {
      const loader = cartItem.querySelector('.loader');
      const quantityNumber = cartItem.querySelector('.quantity-number');
      if (loader) {
        loader.style.display = 'block';
      }
      if (quantityNumber) { // Hide the text but keep the element visible for the loader
        quantityNumber.style.display = 'none';
      }
    }

    fetch('/cart.js').then(response => response.json()).then(cart => {
      const item = cart.items.find(i => i.key === itemKey);
      if (! item) {
        console.error('Item not found for key:', itemKey);
        return;
      }
      let newQuantity = (change === 0)
        ? 0
        : item.quantity + change;
      if (newQuantity < 0) 
        newQuantity = 0;
      


      console.log(`Changing quantity of ${
        item.title
      } from ${
        item.quantity
      } to ${newQuantity}`);

// Preserve the item properties when updating quantity
      const properties = item.properties || {};

// Ensure discount_tiers property is correctly preserved
      if (properties._discount_tiers) {
        console.log('Preserving discount tiers during quantity update:', properties._discount_tiers);
      } else if (newQuantity > 0 && localStorage.getItem('last_added_discount_tiers')) { // Try to recover from local storage if property was lost
        try {
          const lastTiers = localStorage.getItem('last_added_discount_tiers');
          if (itemKey.includes(item.product_id) && cart.items.indexOf(item) === 0) { // Only apply to first variant of the product
            properties._discount_tiers = lastTiers;
            console.log('Recovered discount tiers from local storage:', lastTiers);
          }
        } catch (e) {
          console.error('Error recovering discount tiers:', e);
        }
      }

      fetch('/cart/change.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(
          {id: itemKey, quantity: newQuantity, properties: properties}
        )
      }).then(response => response.json()).then(updatedCart => {
        console.log('Cart updated:', updatedCart);
        updateCartUI();

// Hide all loaders after cart UI is updated
        document.querySelectorAll('.loader').forEach(loader => {
          loader.style.display = 'none';
        });
      }).catch(error => {
        console.error('Error updating cart item:', error);

// Hide loader on error and restore quantity display
        document.querySelectorAll('.loader').forEach(loader => {
          loader.style.display = 'none';
        });

// Restore original quantity text if update failed
        if (cartItem) {
          const quantityNumber = cartItem.querySelector('.quantity-number');
          if (quantityNumber) {
            quantityNumber.style.display = 'block';
          }
        }
      });
    }).catch(error => {
      console.error('Error fetching cart:', error);

// Hide loader on error and restore quantity display
      document.querySelectorAll('.loader').forEach(loader => {
        loader.style.display = 'none';
      });

// Restore original quantity text if update failed
      if (cartItem) {
        const quantityNumber = cartItem.querySelector('.quantity-number');
        if (quantityNumber) {
          quantityNumber.style.display = 'block';
        }
      }
    });
  }

// --- Checkout Button Event ---
  const checkoutButton = document.querySelector('.checkout-button');
  if (checkoutButton) {
    checkoutButton.addEventListener('click', function() {

// Get all items from cart, update properties if needed, then redirect to checkout
      fetch('/cart.js').then(response => response.json()).then(cart => {
        window.location.href = '/checkout';
      }).catch(error => console.error('Error processing checkout:', error));
    });
  }

// --- Close Cart Event ---
  const closeCartButton = document.getElementById('closeCart');
  if (closeCartButton) {
    closeCartButton.addEventListener('click', function() {
      closeCart();
    });
  }

// --- Initialize Cart UI on Page Load ---
  updateCartUI();
});

document.addEventListener('DOMContentLoaded', () => {
  const searchBar = document.getElementById('searchBar');
  const searchResults = document.createElement('div');
  searchResults.id = 'searchResults';
  searchBar.parentNode.appendChild(searchResults);

// Add styles for search results
  const style = document.createElement('style');
  style.textContent = `
#searchResults {
position: absolute;
width: 100%;
top: 100%;
max-height: 400px;
overflow-y: auto;
background: white;
box-shadow: 0 4px 6px rgba(0,0,0,0.1);
z-index: 1000;
display: none;
}
.search-item {
padding: 10px;
border-bottom: 1px solid #eee;
cursor: pointer;
}
.search-item:hover {
background: #f8f9fa;
}
`;
  document.head.appendChild(style);

// Debounce function to limit API calls
  const debounce = (func, delay) => {
    let timeout;
    return(...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), delay);
    };
  };

// Fetch search results from Shopify
  const fetchSearchResults = async (query) => {
    try {
      const response = await fetch(`/search/suggest.json?q=${
        encodeURIComponent(query)
      }&resources[type]=product&resources[limit]=10`);
      const data = await response.json();
      return data.resources.results.products;
    } catch (error) {
      console.error('Search error:', error);
      return [];
    }
  };

// Display search results
  const displayResults = (products) => {
    searchResults.innerHTML = '';
    if (products.length === 0) {
      searchResults.innerHTML = `<div class="search-item">No results found</div>`;
      searchResults.style.display = 'block';
      return;
    }

    products.forEach(product => {
      const item = document.createElement('a');
      item.className = 'search-item d-block text-decoration-none text-dark';
      item.href = product.url;
      item.innerHTML = `
<div class="d-flex align-items-center">
<img class="thumbnailSearch ps-2 object-fit-contain" src="${
        product.image
      }" alt="${
        product.title
      }" width="50" height="50" class="me-3">
<div class="ps-3">
<h6 class="mb-0 text-main">${
        product.title
      }</h6>
<small class="text-main">${
        product.price || money_with_currency
      }â‚¬</small>
</div>
</div>
`;
      searchResults.appendChild(item);
    });
    searchResults.style.display = 'block';
  };

// Handle search input
  const handleSearch = debounce(async (e) => {
    const query = e.target.value.trim();
    if (query.length < 2) {
      searchResults.style.display = 'none';
      return;
    }

    const results = await fetchSearchResults(query);
    displayResults(results);
  }, 300);

// Event listeners
  searchBar.addEventListener('input', handleSearch);

// Hide results when clicking outside
  document.addEventListener('click', (e) => {
    if (! searchBar.contains(e.target)) {
      searchResults.style.display = 'none';
    }
  });

// Handle keyboard navigation
  searchBar.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      searchResults.style.display = 'none';
    }
  });
});

// setTimeout(() => {
// document.addEventListener('DOMContentLoaded', () => {
// const markOne = document.querySelector('.mark-value-0');
// console.log(markOne);
// })
// console.log('Hello');
// }, 1000);
document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('quantitySlider');
  const qtyInput = document.getElementById('quantityInput');
  const unitPriceEl = document.getElementById('unitPrice');
  const perPieceEl = document.getElementById('perPiece');
  const totalPriceEl = document.getElementById('totalPrice');
  const discountLabel = document.getElementById('activeDiscountLabel');

  let baseCents = parseInt(document.querySelector('#package-options .package-box.selected') ?. dataset.price || document.querySelector('#package-options .package-box') ?. dataset.price, 10) || {{ product.price | times: 100 }};

  let pieces = parseInt(document.querySelector('#package-options .package-box.selected') ?. dataset.pieces || 1, 10);

// Add event listeners to package boxes to update price variables when clicked
  const packageBoxes = document.querySelectorAll('#package-options .package-box');
  if (packageBoxes.length > 0) {
    packageBoxes.forEach(box => {
      box.addEventListener('click', function() {

// Update baseCents and pieces when a variant is selected
        baseCents = parseInt(this.dataset.price, 10) || baseCents;
        pieces = parseInt(this.dataset.pieces, 10) || pieces;

// Reset quantity to 1 when variant is changed
        if (qtyInput) {
          qtyInput.value = 1;
        }

        if (slider) {
          slider.setAttribute('value', 1);
        }

// Recalculate prices with quantity 1
        recalcPrices(1);
      });
    });
  }

  function recalcPrices(qty) {

// 1. Determine discount rate from metafields
    let discountRate = 0;
    if (window.discountTiers && window.discountTiers.tiers) { // Sort tiers by min value in descending order to get highest applicable tier
      const sortedTiers = [...window.discountTiers.tiers].sort((a, b) => b.min - a.min);

// Find the highest tier where quantity meets or exceeds minimum
      for (const tier of sortedTiers) {
        if (qty >= tier.min) {
          discountRate = tier.discount / 100; // Convert percentage to decimal
          break;
        }
      }
    }
  }

// ... rest of the existing code ...
});

// Discount Tiers Display Handler
document.addEventListener('DOMContentLoaded', () => {

// Initialize discount display
  const quantityInput = document.getElementById('quantityInput');
  const quantitySlider = document.getElementById('quantitySlider');
  const discountDisplay = document.getElementById('discountDisplay');
  const variantPriceElement = document.getElementById('variant-price');
  const originalPriceElement = document.getElementById('original-price-data');

  if (quantityInput && discountDisplay) { // Function to update the discount display and prices based on quantity
    function updateDiscountDisplay(quantity) {

// Get original price data
      let originalPrice = parseInt(originalPriceElement ?. getAttribute('data-price')) || 0;
      let piecesPerPack = parseInt(originalPriceElement ?. getAttribute('data-pieces')) || 1;

// Check if we're on the first variant - only apply discounts to first variant
      const selectedVariant = document.querySelector('#package-options .package-box.selected');
      const allVariants = document.querySelectorAll('#package-options .package-box');
      const isFirstVariant = selectedVariant && allVariants.length > 0 && selectedVariant === allVariants[0];

      if (! isFirstVariant || !window.discountTiers || !window.discountTiers.tiers || window.discountTiers.tiers.length === 0) { // No discount scenario
        discountDisplay.textContent = '';
        discountDisplay.classList.remove('text-discount');

// Hide the discount badge
        const discountBadge = document.querySelector('.discount-percentage-badge');
        if (discountBadge) {
          discountBadge.style.display = 'none';
        }

// Update the price without discount
        if (variantPriceElement) {
          const formattedPrice = Shopify.formatMoney(originalPrice * quantity, window.shopMoneyFormat);
          const pricePerPiece = originalPrice / piecesPerPack;
          const formattedPricePerPiece = Shopify.formatMoney(pricePerPiece, window.shopMoneyFormat);

          variantPriceElement.innerHTML = `${formattedPrice} 
            <span class="perPiece pb-2" id="price-per-piece">
              (${formattedPricePerPiece}) per ${
            window.unitLabel || 'piece'
          }
            </span>`;

// Update compare price and make it visible
          const comparePrice = document.getElementById('compare-price');
          if (comparePrice) {
            const variantCompareAtPrice = selectedVariant
              ? parseInt(selectedVariant.getAttribute('data-compare-at-price')) || 0
              : 0;

            if (variantCompareAtPrice && variantCompareAtPrice > originalPrice) {
              comparePrice.textContent = Shopify.formatMoney(variantCompareAtPrice * quantity, window.shopMoneyFormat);
              comparePrice.classList.remove('d-none');
              comparePrice.style.display = 'block';
            } else {
              comparePrice.classList.add('d-none');
              comparePrice.style.display = 'none';
            }
          }
        }
        return;
      }

// Find the applicable discount tier
      const sortedTiers = [...window.discountTiers.tiers].sort((a, b) => b.min - a.min);
      let applicableTier = null;

// Find highest applicable tier
      for (const tier of sortedTiers) {
        if (quantity >= tier.min) {
          applicableTier = tier;
          break;
        }
      }

// Update the display and price
      if (applicableTier) { // Calculate discounted price
        const discountPercentage = applicableTier.discount;

// Use Math.floor for per-item discount calculation to match Shopify's approach
        const discountAmount = Math.floor((originalPrice * discountPercentage) / 100);
        const discountedPricePerItem = originalPrice - discountAmount;
        const totalDiscountedPrice = discountedPricePerItem * quantity;

// Calculate the actual amount saved in euros
        const originalTotalPrice = originalPrice * quantity;
        const totalDiscountAmount = originalTotalPrice - totalDiscountedPrice;

// Update discount display text with raw value in data attribute
        discountDisplay.setAttribute('data-discount-amount', totalDiscountAmount);
        const discountText = `${
          translations.youCurrentlySave
        } ${
          Shopify.formatMoney(totalDiscountAmount)
        } ${
          translations.offYourTotalOrder
        }`;
        discountDisplay.textContent = discountText;
        discountDisplay.classList.add('text-discount');

// Also update the discount badge - but only show the percentage number
        const discountBadge = document.querySelector('.discount-percentage-badge');
        if (discountBadge) {
          discountBadge.textContent = `-${
            applicableTier.discount
          }%`;

          discountBadge.style.display = 'block';

// Make sure it's visible

// Hide compare price when discount badge is visible
          const comparePrice = document.getElementById('compare-price');
          if (comparePrice) {
            comparePrice.style.display = 'none';
          }
        }

// Update price display with discount
        if (variantPriceElement) {
          const formattedDiscountedPrice = Shopify.formatMoney(totalDiscountedPrice, window.shopMoneyFormat);
          const formattedOriginalPrice = Shopify.formatMoney(originalTotalPrice, window.shopMoneyFormat);

// Calculate and format price per piece (based on discounted price)
          const discountedPricePerPiece = discountedPricePerItem / piecesPerPack;
          const formattedPricePerPiece = Shopify.formatMoney(discountedPricePerPiece, window.shopMoneyFormat);

// Update HTML with strikethrough for original price
          variantPriceElement.innerHTML = `${formattedDiscountedPrice} 
            <span class="perPiece pb-2" id="price-per-piece">(${formattedPricePerPiece}) per ${
            window.unitLabel || 'piece'
          }</span>`;

// Add the original price to the discount container instead
          const discountContainer = document.querySelector('.discount-container');
          if (discountContainer) {
            const discountSpan = document.createElement('span');
            discountSpan.className = 'discount-price-product fw-light roboto-font user-select-none';
            discountSpan.textContent = formattedOriginalPrice;

// Clear previous discount span if it exists
            const existingDiscount = discountContainer.querySelector('.discount-price-product');
            if (existingDiscount) {
              existingDiscount.remove();
            }

            discountContainer.appendChild(discountSpan);
          }
        }
      } else {

// No applicable discount tier
// Hide the discount text completely
        discountDisplay.textContent = '';
        discountDisplay.classList.remove('text-discount');

// Hide the discount badge when there's no discount
        const discountBadge = document.querySelector('.discount-percentage-badge');
        if (discountBadge) {
          discountBadge.textContent = '';
          discountBadge.style.display = 'none';
        }

// Show compare price when no discount is applied
        const comparePrice = document.getElementById('compare-price');
        if (comparePrice) { // Check if there's a valid compare-at-price to show
          const selectedVariant = document.querySelector('#package-options .package-box.selected');
          const variantCompareAtPrice = selectedVariant
            ? parseInt(selectedVariant.getAttribute('data-compare-at-price')) || 0
            : 0;

          if (variantCompareAtPrice && variantCompareAtPrice > originalPrice) { // Multiply compare-at-price by quantity, just like regular price
            const currentQuantity = parseInt(quantityInput.value) || 1;
            const totalCompareAtPrice = variantCompareAtPrice * currentQuantity;
            comparePrice.textContent = Shopify.formatMoney(totalCompareAtPrice, window.shopMoneyFormat);
            comparePrice.classList.remove('d-none');
            comparePrice.style.display = 'block';
          } else { // No compare-at-price, keep it hidden
            comparePrice.classList.add('d-none');
            comparePrice.style.display = 'none';
          }
        }

// Update price without discount
        if (variantPriceElement) {
          const formattedPrice = Shopify.formatMoney(originalPrice * quantity, window.shopMoneyFormat);
          const pricePerPiece = originalPrice / piecesPerPack;
          const formattedPricePerPiece = Shopify.formatMoney(pricePerPiece, window.shopMoneyFormat);

          variantPriceElement.innerHTML = `${formattedPrice} 
            <span class="perPiece pb-2" id="price-per-piece">
              (${formattedPricePerPiece}) per ${
            window.unitLabel || 'piece'
          }
            </span>`;
        }
      }
    }

// Add event listeners
    quantityInput.addEventListener('input', (e) => {
      updateDiscountDisplay(parseInt(e.target.value) || 1);
    });

    if (quantitySlider) {
      quantitySlider.addEventListener('change', function(e) {
        const newVal = e.detail && e.detail.value !== undefined
          ? e.detail.value
          : quantitySlider.getAttribute('value');
        updateDiscountDisplay(parseInt(newVal) || 1);
      });

      quantitySlider.addEventListener('input', function(e) {
        const newVal = e.detail && e.detail.value !== undefined
          ? e.detail.value
          : quantitySlider.getAttribute('value');
        updateDiscountDisplay(parseInt(newVal) || 1);
      });
    }

// Initialize with current quantity
    updateDiscountDisplay(parseInt(quantityInput.value) || 1);
  }
});

// --- Discount Code Functionality ---
document.addEventListener('DOMContentLoaded', function() {
  const discountInput = document.getElementById('discount-code');
  const orderDiscountsRow = document.querySelector('.d-flex.align-items-center.justify-content-between.py-2.d-none');
  const orderDiscountsAmount = document.getElementById('order-discounts');

  if (discountInput) { // Add event listener for the Enter key
    discountInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        applyDiscountCode();
      }
    });

// Add a blur event to apply discount when input loses focus
    discountInput.addEventListener('blur', function() {
      if (discountInput.value.trim()) {
        applyDiscountCode();
      }
    });

// Function to apply discount code
    function applyDiscountCode() {
      const code = discountInput.value.trim();
      if (! code) return;
      


// Show loading state
      discountInput.disabled = true;

// Apply discount code to cart
      fetch('/discount/' + code, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      })
        .then(response => {
          if (!response.ok) {
            throw new Error('Invalid discount code');
          }
          return fetch('/cart.js'); // Get updated cart data
        })
        .then(response => response.json())
        .then(cart => {

  // Show the discounts row if there are discounts
          if (cart.total_discount > 0) {
            orderDiscountsRow.classList.remove('d-none');
            orderDiscountsAmount.setAttribute('data-discount', cart.total_discount);
            orderDiscountsAmount.textContent = '-' + Shopify.formatMoney(cart.total_discount);

  // Update subtotal
            document.querySelectorAll('.cart-subtotal').forEach(function(subtotalElem) {
              subtotalElem.setAttribute('data-subtotal', cart.total_price);
              subtotalElem.textContent = Shopify.formatMoney(cart.total_price);
            });
          }

  // Success feedback
          discountInput.classList.add('is-valid');
          setTimeout(() => discountInput.classList.remove('is-valid'), 2000);
        })
        .catch(error => {
          console.error('Error applying discount:', error);

// Error feedback
          discountInput.classList.add('is-invalid');
          setTimeout(() => discountInput.classList.remove('is-invalid'), 2000);
        })
        . finally(() => {
          discountInput.disabled = false;
        });
    }
  }
});

// --- Currency Update Handler ---
// This function updates all monetary displays when the currency changes
function updateAllCurrencyDisplays() {
  console.log('Currency updated, refreshing monetary displays');

// Update cart UI which handles shipping costs and subtotals
  if (typeof updateCartUI === 'function') {
    updateCartUI();
  }

// Refresh free shipping text displays if the function exists
  if (typeof formatFreeShippingText === 'function') {
    formatFreeShippingText();
  }
}

// Listen for currency change events
document.addEventListener('currency_change', function(e) {
  updateAllCurrencyDisplays();
});

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {

// Initial update of monetary displays with current currency
  updateAllCurrencyDisplays();
});